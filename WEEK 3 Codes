E1) REMOVE DUPLICATES FROM SORTED LIST

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* curr= head;
        while (curr && curr->next){
            if (curr->val == curr->next->val)
                {curr->next = curr->next->next;}
            else{
                curr = curr->next;}
        }
        return head;
    }
};


E2) INSERTION SORT LIST

class Solution {
public:
    ListNode* insertionSortList(ListNode* head){
        if (head == NULL || head->next ==NULL){
            return head;}

        ListNode temp(0);
        temp.next = head;

        ListNode* last = head;
        ListNode* curr =head->next;

        while (curr != NULL) {
            if (last->val <= curr->val) {
                last = curr;
                curr = curr->next;} 
            else {
                ListNode* ptr = &temp;
                while (ptr->next->val < curr->val){
                    ptr = ptr->next;
                }

                last->next = curr->next;
                curr->next = ptr->next;
                ptr->next = curr;
                curr = last->next;
            }
        }
        return temp.next;
    }
};



E3) DESIGN CIRCULAR QUEUE

class MyCircularQueue {
public:
    int *arr;
    int front;
    int rear;
    int size;

    MyCircularQueue(int k) {
        size = k + 1;
        arr = new int[size];
        front = 0;
        rear = 0;
    }

    bool enQueue(int value) {
        if (isFull()) return false;
        arr[rear] = value;
        rear = (rear + 1) % size;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) 
            return false;
        front = (front + 1) % size;
        return true;
    }

    int Front() {
        if (isEmpty()) 
            return -1;
        return arr[front];
    }

    int Rear() {
        if (isEmpty()) return -1;
        return arr[(rear-1+size) % size];
    }

    bool isEmpty(){
        return front== rear;
    }

    bool isFull(){
        return (rear + 1) % size == front;}
};




E4) ASTEROID COLLISION

class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids){
        vector<int> st;

        for (int i = 0; i < asteroids.size(); i++){
            int curr = asteroids[i];
            bool alive = true;

            while (!st.empty() && curr < 0 && st.back() > 0) {
                if (abs(st.back()) < abs(curr)) {
                    st.pop_back();
                    continue;
                } 
                else if (abs(st.back()) == abs(curr)) {
                    st.pop_back();
                }
                alive =false;
                break;
            }

            if (alive){ 
                st.push_back(curr);}
        }

        return st;
    }
};



E5)  WINNER OF THE CICULAR GAME

class Solution {
public:
    int findTheWinner(int n, int k) {
        int win = 0;

        for (int i=1; i <= n; i++) {
            win = (win+k) % i;
        }

        return win + 1;
    }
};



A1) DESIGN TWITTER

class Twitter {
public:
    int time;
    unordered_map<int, vector<pair<int,int>>> tweets;
    unordered_map<int, unordered_set<int>> follows;

    Twitter() {
        time = 0;
    }

    void postTweet(int userId, int tweetId) {
        tweets[userId].push_back({time++, tweetId});
    }

    vector<int> getNewsFeed(int userId) {
        priority_queue<pair<int,int>> pq;
        vector<int> res;

        for (auto &t : tweets[userId])
            pq.push(t);

        for (int f : follows[userId]) {
            for (auto &t : tweets[f])
                pq.push(t);
        }

        while (!pq.empty() && res.size() < 10) {
            res.push_back(pq.top().second);
            pq.pop();
        }

        return res;
    }

    void follow(int followerId, int followeeId) {
        if (followerId != followeeId)
            follows[followerId].insert(followeeId);
    }

    void unfollow(int followerId, int followeeId) {
        follows[followerId].erase(followeeId);
    }
};


A2) MAXIMUM NUMBER OF ROBOTS WITHIN BUDGET

class Solution {
public:
    int maximumRobots(vector<int>& chargeTimes, vector<int>& runningCosts, long long budget) {
        deque<int> dq;
        long long sum =0;
        int left =0;
        int ans =0;

        for (int right= 0; right < chargeTimes.size(); right++){
            sum += runningCosts[right];

            while (!dq.empty() && chargeTimes[dq.back()] <= chargeTimes[right])
                {dq.pop_back();}
            dq.push_back(right);

            while (!dq.empty() &&
                   chargeTimes[dq.front()] + (right - left + 1) * sum > budget){
                if (dq.front() == left)
                    dq.pop_front();
                sum -= runningCosts[left];
                left++;
            }

            ans = max(ans, right-left+1);
        }

        return ans;
    }
};



A3) MAX CHUNKS TO MAKE SORTED 2

class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        vector<int> stk;

        for (int x : arr) {
            if (stk.empty() || x >= stk.back()) {
                stk.push_back(x);
            } else {
                int a = stk.back();
                while (!stk.empty() && stk.back() > x){
                    stk.pop_back();}
                stk.push_back(a);
            }
        }

        return stk.size();
    }
};


A4) DESIGN A TEXT EDITOR

class TextEditor {
public:
    deque<char> left, right;

    TextEditor() {}

    void addText(string text){
        for (char c : text)
            left.push_back(c);
    }

    int deleteText(int k) {
        int cnt = 0;
        while (k-- && !left.empty()) {
            left.pop_back();
            cnt++;}
        return cnt;
    }

    string cursorLeft(int k) {
        while (k-- && !left.empty()) {
            right.push_front(left.back());
            left.pop_back();
        }
        string res;
        int cnt = 0;
        for (int i = max(0, (int)left.size()-10); i < left.size(); i++)
            res += left[i];
        return res;
    }

    string cursorRight(int k) {
        while (k-- && !right.empty()) {
            left.push_back(right.front());
            right.pop_front();
        }
        string res;
        int cnt = 0;
        for (int i = max(0,(int)left.size()-10); i < left.size(); i++)
            res += left[i];
        return res;
    }
};


A5) POPULATE NEXT RIGHT POINTERS IN EACH


